= Java autosuggest engine for ANTLR4 grammars
Oran Epelbaum
:groupid: com.intigua
:version: 0.0.1-SNAPSHOT
:source-highlighter: pygments

To get started, have a look at the unit tests.

image:https://circleci.com/gh/oranoran/antlr4-autosuggest.svg?style=shield&circle-token=:circle-token[link="https://circleci.com/gh/oranoran/antlr4-autosuggest"] image:https://codecov.io/gh/oranoran/antlr4-autosuggest/branch/master/graph/badge.svg[link="https://codecov.io/gh/oranoran/antlr4-autosuggest"] image:https://api.codacy.com/project/badge/Grade/496e60ce37e64674a32551590a8135e9[link="https://www.codacy.com/app/oranoran/antlr4-autosuggest?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=oranoran/antlr4-autosuggest&amp;utm_campaign=Badge_Grade"]

== Getting antlr-autosuggest

For now, you need to download and build the library from source code.
We intend to publish into Maven Central soon.

== Examples

A - Generating suggestions for a generated grammar

```java
LexerAndParserFactory lexerAndParserfactory = new ReflectionLexerAndParserFactory(
        MyGeneratedLexer.class, MyGeneratedParser.class);
Collection<String> suggestions = new AutoComplete(lexerAndParserFactory, "CompleteThisTex").suggestCompletions();
```

== How It Works
ANTLR4 grammars translate into two engines: the *lexer* and the *parser*. To understand auto-suggestions, we first need to understand what these engines do and how they interact.

The lexer is defined by (suprisingly) the "lexer rules" part of the grammar. That's the rules at the bottom of your .g4 file, that start with a capital letter.
The lexer also uses tokens defined directly inside parser rules, so if you have parser rules like ```myrule: 'AA' | 'BB'```, the lexer will care about the ```'AA'``` and ```'BB'``` parts of this rule, but not about other parts.
Using all these rules, the lexer reads the input text, and parses it into a list of *tokens(. Tokens are kind of like the words in a sentence. They don't carry much meaning on their own, but you have to use them to build compex sentences.

The parser part of ANTLR4 is defined (again, surprise!) by the "parser rules" part of the grammar. That's the rules at the top, that start with a lowercase letter. The parser rules define basically in what order and combination words (tokens) can appear in a sentence. Parser rules can also refer to other parser rules to create complex, hierarchical structures.

To use an ANTLR4 grammar, you first run the text through the lexer to cut it into tokens, and then feed the resulting tokens into a parser. The parser can then describe, using callbacks or a tree walk, the structure of the text - including the role of each token in the text.

Ok, now back to autosuggest. So to be able to suggest completions to a given text, this library goes through the following steps:

. Run the text through a lexer, and see if the entire text can be lexed successfully. For example, if we get an input like ```Please complete this tex```, the English lexer would fail at ```tex```, because that's just part of a word. So the autosuggest engine needs to kick in after the tokens ```Please```, ```complete``` and ```this```. The ```tex``` part if not important right now, we'll get back to it later. By the way, if the lexer can parse the whole text, that's also fine. This means the autosuggest engine should kick in after the very last token.
. Now run the tokens from the previous step through the parser's internal state machine, known as the ATN. The ATN is really the heart of the ANTLR4 runtime. It's a simple state machine that describes, given a current state, what are the possible next tokens, and the next state to go to for each allowed token. + 
For example, at the start of a sentence (let's call the start of a sentence "state 0"), the token ```Please``` is allowed. When ```Please``` is received, it transitions the ATN to a new state (let's call it "state 1"). In this state, the parser is now expecting a verb token like ```complete```. After receiving such a verb token, it will move again to a new state, where it will expect a noun again, such as ```text```, or maybe a pronoun such as ```this```. And so on. What we care about for the purpose of autosuggest, is the final parser state after consuming all the tokens from the last step. This will tell us what we're really interested in - which tokens can come next after the current text.
. Now comes the magic ingredient: The lexer also has an ATN of its own, which it uses to read a stream of individual characters and turn them into tokens. The lexer ATN and the parser ATN have an overlap - meaning some states appear in both ATNs. Think of this as the states where one token ends and another one starts - both the parser and the lexer care about token beginning and end, though for different purposes. The parser uses these states to look at token relationships, while the lexer uses them to identify token boundaries. Anyway, the autosuggest engine now runs through the lexer's ATN, starting at the last parser state, to figure out what tokens can come next. These are going to be the auto-suggest results.
. Remember the redundant ```tex``` from above? Well, it's not enough for the auto-suggest results to be valid tokens for their place, they also need to match any text that we dropped at step 1. So maybe I have potential completion tokens like ```assignment```, ```work```, ```form``` and ```text```, but only ```text``` matches the ```tex``` partial token, and so all the other options are dropped. In fact, these irrelevent tokens are already dropped during the lexer ATN processing.
. The final step is to take a look at the entire suggested sentence. The lexer is kind of dumb, and it's possible that it will suggest valid tokens that don't actually make sense in the sentence as a whole, i.e. the parser won't like them. For example, ```Please complete this textile``` is technically a valid completion, but doesn't make any sense in English. So we run the parser one last time on each of the suggested completions, and filter out those suggestions that make the parser fail.

Maybe this sounds complex, but once you get the core concepts like parser, lexer and ATN, it all makes sense. Read the code to get the details picture.

== Building
. Clone the antlr-autosuggest repository.
. Install Java 8 and Maven if not already available
. Run the command `mvn install`.

== Credits
Written by Oran Epelbaum at Intigua.
When starting to write this, studied the following blog posts (though much has changed since):

- https://blog.rapid7.com/2015/06/29/how-to-implement-antlr4-autocomplete/[RAPID7]: How to Implement ANTLR4 Autocomplete
- https://tomassetti.me/autocompletion-editor-antlr/[TOMASETTI]: Building autocompletion for an editor based on ANTLR by Federico Tomassetti
